let s:base_column_query = 'select table_name,column_name from information_schema.columns'
let s:query = s:base_column_query.' order by column_name asc'
let s:schema_query = 'select table_schema,table_name from information_schema.columns group by table_schema,table_name'
let s:count_query = 'select count(*) as total from information_schema.columns'
let s:table_column_query = s:base_column_query.' where table_name={db_tbl_name}'
let s:reserved_words = vim_dadbod_completion#reserved_keywords#get_as_dict()
let s:quote_rules = {
      \ 'camelcase': {val -> val =~# '[A-Z]' && val =~# '[a-z]'},
      \ 'space': {val -> val =~# '\s'},
      \ 'reserved_word': {val -> has_key(s:reserved_words, toupper(val))},
      \ 'any_lower': {val -> val =~# '[a-z]'}
      \ }

function! s:map_and_filter(delimiter, list) abort
  return filter(
        \ map(a:list, { _, table -> map(split(table, a:delimiter), 'trim(v:val)') }),
        \ 'len(v:val) ==? 4'
        \ )
endfunction

function! s:should_quote(rules, val) abort
  if empty(trim(a:val))
    return 0
  endif

  let do_quote = 0

  for rule in a:rules
    let do_quote = s:quote_rules[rule](a:val)
    if do_quote
      break
    endif
  endfor

  return do_quote
endfunction

function! s:count_parser(index, result) abort
  return str2nr(get(a:result, a:index, 0))
endfunction

let s:postgres = {
      \ 'column_query': printf('-A -c "%s"', s:query),
      \ 'count_column_query': printf('-A -c "%s"', s:count_query),
      \ 'table_column_query': {table -> printf('-A -c "%s"', substitute(s:table_column_query, '{db_tbl_name}', "'".table."'", ''))},
      \ 'functions_query': printf('-A -c "%s"', "SELECT routine_name FROM information_schema.routines WHERE routine_type='FUNCTION'"),
      \ 'functions_parser': {list->list[1:-4]},
      \ 'schemas_query': printf('-A -c "%s"', s:schema_query),
      \ 'schemas_parser': function('s:map_and_filter', ['|']),
      \ 'quote': ['"', '"'],
      \ 'should_quote': function('s:should_quote', [['camelcase', 'reserved_word', 'space']]),
      \ 'column_parser': function('s:map_and_filter', ['|']),
      \ 'count_parser': function('s:count_parser', [1])
      \ }

let s:oracle_args = "echo \"SET HEADING OFF;\nSET FEEDBACK OFF;\nSET linesize 4000;\nSET pagesize 4000;\n%s\" | "
let s:oracle_base_column_query = printf(s:oracle_args, "
	\ SET COLSEP |;\n
	\ COLUMN column_name FORMAT a100;\n
	\ COLUMN table_name FORMAT a50;\n
	\ COLUMN object_type FORMAT a25;\n
	\ COLUMN object_info FORMAT a2000;\n
	\ select table_name, column_name, object_type, nvl(object_info, '(empty)') as object_info 
	\ from (
	\ 	select c.table_name as table_name
	\ 		, c.column_name as column_name
	\ 		, 'CO' as object_type
	\ 		, c.data_type || nvl2(c.data_precision, decode(c.data_scale
	\ 					, 0, '(' || c.data_precision || ')'
	\ 					, '(' || c.data_precision || ', ' || c.data_scale || ')'
	\ 				)
	\ 				, nvl2(c.data_scale, '(*, ' || c.data_scale || ')'
	\ 					, decode(c.char_length, null, null, 0, null, '(' || c.char_length || 
	\ 							decode(c.char_used, 'B', ' BYTE', 'C', ' CHAR') || ')'
	\ 					)
	\ 				)
	\ 			) || decode(c.nullable, 'N', ' NOT NULL') || nvl2(co.comments, ' -- ' || co.comments, null
	\ 			) as object_info
	\ 		, null as overload	
	\ 	from all_tab_columns c
	\ 		join all_col_comments co on co.owner = c.owner and co.table_name = c.table_name and co.column_name = c.column_name 
	\ 		join all_users u on c.owner = u.username 
	\ 	where u.common = 'NO' 
	\ 	union 
	\ 	select p.object_name as table_name
	\ 		, nvl(p.procedure_name, p.object_name) || 
	\ 					nvl2(p.procedure_name, '(', null) ||
	\ 					(select listagg(c.argument_name || '=>NULL', ',') within group (order by c.sequence)
	\ 					from all_arguments c 
	\ 					where c.owner = p.owner and c.object_id = p.object_id and c.subprogram_id = p.subprogram_id and (c.overload = p.overload or c.overload is null) and c.argument_name is not null and c.defaulted != 'Y' and c.subprogram_id != 0
	\ 					) || nvl2(p.procedure_name, ')', null) as column_name
	\ 		, substr(p.object_type, 1, 2) as object_type
	\ 		, (select listagg(decode(c.sequence, 1, nvl2(c.argument_name, '', 'RETURN: ')) ||
	\ 				c.argument_name || ' ' || c.in_out || ' ' ||
	\ 				nvl(c.type_name, c.data_type) || nvl2(c.data_precision, decode(c.data_scale
	\ 						, 0, '(' || c.data_precision || ')'
	\ 						, '(' || c.data_precision || ',' || c.data_scale || ')'
	\ 					)
	\ 					, nvl2(c.data_scale	, '(*,' || c.data_scale || ')'
	\ 						, decode(c.char_length, null, null, '0', null, '(' || c.char_length || 
	\ 								decode(c.char_used, 'B', ' BYTE', 'C', ' CHAR') || ')', null
	\ 						)
	\ 					)
	\ 				) || decode(c.defaulted	, 'Y', ' DEFAULTED') 
	\ 			, ', ') within group (order by to_number(decode(c.sequence, 1, null, c.sequence)) nulls last)
	\ 		from all_arguments c 
	\ 		where c.owner = p.owner and c.object_id = p.object_id and c.subprogram_id = p.subprogram_id and (c.overload = p.overload or c.overload is null) and (c.sequence = 1 or c.argument_name is not null) and c.subprogram_id != 0
	\ 		) as object_info
	\ 		, to_number(p.overload) as overload
	\ 	from all_procedures p
	\ 		left join all_users u on p.owner = u.username 
	\ 	where (u.common is not null and u.common = 'NO') 
	\ 			or (1 = 0 and p.owner = 'SYS' and substr(p.object_name, 1, 5) = 'DBMS_')
	\ 	group by p.owner, p.object_id, p.subprogram_id, p.object_name, p.procedure_name, p.object_type, p.overload
	\ 	order by 1, 2, 4 nulls first
	\ ) where 1=1 %s;")
let s:oracle = {
\   'column_parser': function('s:map_and_filter', ['|']),
\   'column_query': printf(s:oracle_base_column_query, 'ORDER BY column_name ASC'),
\   'count_column_query': printf(s:oracle_args, "COLUMN total FORMAT 9999999;\nSELECT COUNT(*) AS total FROM all_tab_columns C JOIN all_users U ON C.owner = U.username WHERE U.common = 'NO';"),
\   'count_parser': function('s:count_parser', [1]),
\   'quote': ['"', '"'],
\   'schemas_query': printf(s:oracle_args, "
	\ SET COLSEP |;\n
	\ COLUMN owner FORMAT a50;\n
	\ COLUMN table_name FORMAT a50;\n
	\ COLUMN object_type FORMAT a100;\n
	\ COLUMN object_info FORMAT a500;\n
	\ select o.owner
	\ 	, object_name || 
	\ 		case
	\ 			when object_type in ('PROCEDURE', 'FUNCTION') then
	\ 				'(' ||
	\ 				(select listagg(c.argument_name || '=>NULL', ',') within group (order by c.sequence)
	\ 				from all_arguments c 
	\ 				where c.owner = o.owner and c.object_id = o.object_id and c.argument_name is not null and c.defaulted != 'Y'
	\ 				) || ')' 
	\ 		end table_name
	\ 	, substr(o.object_type, 1, 2) object_type
	\ 	, case 
	\ 		when object_type in ('PROCEDURE', 'FUNCTION') then
	\ 			(select listagg(
	\ 					decode(c.sequence, 1, nvl2(c.argument_name, null, 'RETURN: ')) ||
	\ 					c.argument_name || ' ' ||
	\ 					c.in_out || ' ' ||
	\ 					nvl(c.type_name, c.data_type) || nvl2(c.data_precision, decode(c.data_scale
	\ 							, 0, '(' || c.data_precision || ')'
	\ 							, '(' || c.data_precision || ',' || c.data_scale || ')'
	\ 						)
	\ 						, nvl2(c.data_scale	, '(*,' || c.data_scale || ')'
	\ 							, decode(c.char_length, null, null, '0', null, '(' || c.char_length || 
	\ 									decode(c.char_used, 'B', ' BYTE', 'C', ' CHAR') || ')', null
	\ 							)
	\ 						)
	\ 					) || decode(c.defaulted	, 'Y', ' DEFAULTED') 
	\ 				, ', ') within group (order by to_number(decode(c.sequence, 1, null, c.sequence)) nulls last)
	\ 			from all_arguments c 
	\ 			where c.owner = o.owner and c.object_id = o.object_id and (c.sequence = 1 or c.argument_name is not null)			
	\ 			)
	\ 		else
	\ 			nvl(c.comments, '(empty)')
	\ 	end object_info
	\ from all_objects o 
	\ 	left join all_users u on o.owner = u.username 
	\ 	left join all_tab_comments c on c.owner = o.owner and c.table_name = o.object_name and c.table_type = o.object_type
	\ where (u.common is not null and u.common = 'NO' 
	\ 	and o.object_type in ('TABLE', 'VIEW', 'MATERIALIZED VIEW', 'PROCEDURE', 'FUNCTION', 'PACKAGE', 'SEQUENCE', 'TYPE')) 
	\ 	or (o.owner = 'PUBLIC' and o.object_type in ('SYNONYM') and (o.object_name like 'USER_%' or object_name like 'DBMS_%')) 
	\ group by o.owner, o.object_name, o.object_type, o.object_id, c.comments, u.username
	\ order by u.username asc nulls last, o.object_name;"),
\   'schemas_parser': function('s:map_and_filter', ['|']),
\   'should_quote': function('s:should_quote', [['any_lower', 'reserved_word', 'space']]),
\   'table_column_query': {table -> printf(s:oracle_base_column_query, "AND table_name='".table."'")},
\ }

let s:schemas = {
      \ 'postgres': s:postgres,
      \ 'postgresql': s:postgres,
      \ 'mysql': {
      \   'column_query': printf('-e "%s"', s:query),
      \   'count_column_query': printf('-e "%s"', s:count_query),
      \   'table_column_query': {table -> printf('-e "%s"', substitute(s:table_column_query, '{db_tbl_name}', "'".table."'", ''))},
      \   'schemas_query': printf('-e "%s"', s:schema_query),
      \   'schemas_parser': function('s:map_and_filter', ['\t']),
      \   'quote': ['`', '`'],
      \   'should_quote': function('s:should_quote', [['reserved_word', 'space']]),
      \   'column_parser': function('s:map_and_filter', ['\t']),
      \   'count_parser': function('s:count_parser', [1])
      \ },
      \ 'oracle': s:oracle,
      \ 'sqlserver': {
      \   'column_query': printf('-h-1 -W -s "|" -Q "%s"', s:query),
      \   'count_column_query': printf('-h-1 -W -Q "%s"', s:count_query),
      \   'table_column_query': {table -> printf('-h-1 -W -Q "%s"', substitute(s:table_column_query, '{db_tbl_name}', "'".table."'", ''))},
      \   'schemas_query': printf('-h-1 -W -s "|" -Q "%s"', s:schema_query),
      \   'schemas_parser': function('s:map_and_filter', ['|']),
      \   'quote': ['[', ']'],
      \   'should_quote': function('s:should_quote', [['reserved_word', 'space']]),
      \   'column_parser': function('s:map_and_filter', ['|']),
      \   'count_parser': function('s:count_parser', [0])
      \ },
    \ }

function! vim_dadbod_completion#schemas#get(scheme)
  return get(s:schemas, a:scheme, {})
endfunction

function! vim_dadbod_completion#schemas#get_quotes_rgx() abort
  let open = []
  let close = []
  for db in values(s:schemas)
    if index(open, db.quote[0]) <= -1
      call add(open, db.quote[0])
    endif

    if index(close, db.quote[1]) <= -1
      call add(close, db.quote[1])
    endif
  endfor

  return {
        \ 'open': escape(join(open, '\|'), '[]'),
        \ 'close': escape(join(close, '\|'), '[]')
        \ }
endfunction

